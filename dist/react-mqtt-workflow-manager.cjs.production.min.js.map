{"version":3,"file":"react-mqtt-workflow-manager.cjs.production.min.js","sources":["../src/ducks/workflowManager.slice.ts","../src/utils/constants.ts","../src/utils/isValidTopic.util.ts","../src/utils/shouldSubscribeOrUnsubscribe.util.ts","../src/WorkflowManagerConfig.ts","../src/utils/isValidJSON.util.ts","../src/ducks/utils.ts","../src/contexts/mqtt.context.ts","../src/index.tsx","../src/WorkflowManager.tsx","../src/hooks/useMqtt.hook.ts","../src/hooks/useSubscribe.hook.ts","../src/hooks/useUnsubscribe.hook.ts"],"sourcesContent":["import { createSlice, PayloadAction } from '@reduxjs/toolkit';\n\nimport { WorkflowManagerState } from './types';\n\nconst Types = {\n  addProcess: 'internal/ADD_PROCESS',\n  removeProcess: 'internal/REMOVE_PROCESS',\n};\n\nconst initialState: WorkflowManagerState = {\n  activeProcesses: [],\n};\n\nexport const workflowManagerSlice = createSlice({\n  name: '@@workflowManager',\n  initialState,\n  reducers: {\n    [Types.addProcess]: (state, action: PayloadAction<string>) => {\n      state.activeProcesses.push(action.payload);\n    },\n    [Types.removeProcess]: (state, action: PayloadAction<string>) => {\n      state.activeProcesses = state.activeProcesses.filter(\n        (process) => process !== action.payload,\n      );\n    },\n  },\n});\n\nexport const prefix = workflowManagerSlice.name;\nexport const addProcess = workflowManagerSlice.actions[Types.addProcess];\nexport const removeProcess = workflowManagerSlice.actions[Types.removeProcess];\n\nexport default workflowManagerSlice.reducer;\n","export const VALID_TOPIC_PATTERN =\n  /^(([\\\\+#]{1}|[^\\\\+#]*)\\/)?(([\\\\+#]{1}|[^\\\\+#]*)\\/{1})*(([\\\\+#]{1}|[^\\\\+#]*))$/;\n\nexport const ERROR_MESSAGES = {\n  NO_WRAPPER:\n    'No context found. Did you forget to wrap your app with WorkflowManager component?',\n  NO_VALID_TOPICS:\n    'Invalid MQTT topic(s) pattern(s). Please check your topics in the subscribe method.',\n  ERROR_OCURRED: 'An error occurred in MQTT client.',\n  NOT_CONNECTED: 'MQTT client is not connected.',\n  FAILED_TO_CONNECT:\n    'Failed to connect to MQTT broker. Please, check your connection settings.',\n  NO_STORE: 'No store found. Did you forget to set the store?',\n  INVALID_JSON: 'The MQTT message is not a valid JSON.',\n};\n\nexport const PROCESS_TOPIC_PATTERN = '/process/+processId/am/create';\n","import { VALID_TOPIC_PATTERN } from './constants';\n\nexport const isValidTopic = (topic: string): boolean => {\n  return VALID_TOPIC_PATTERN.test(topic);\n};\n","import { Store } from '@reduxjs/toolkit';\nimport { MqttClient } from 'precompiled-mqtt';\nimport invariant from 'tiny-warning';\n\nimport { ERROR_MESSAGES } from './constants';\nimport { isValidTopic } from './isValidTopic.util';\n\nconst hasStore = (store: Store | null) => {\n  const isValid = store !== null;\n\n  if (!isValid) invariant(false, ERROR_MESSAGES.NO_STORE);\n\n  return isValid;\n};\n\nconst isClientConnected = (client: MqttClient | null) => {\n  const isValid = client?.connected;\n\n  if (!isValid) invariant(false, ERROR_MESSAGES.NOT_CONNECTED);\n\n  return client?.connected;\n};\n\nconst hasAllValidTopics = (topics: string | string[]) => {\n  const isValid = Array.isArray(topics)\n    ? topics.every((topic) => isValidTopic(topic))\n    : isValidTopic(topics);\n\n  if (!isValid) invariant(false, ERROR_MESSAGES.NO_VALID_TOPICS);\n\n  return isValid;\n};\n\nexport const shouldSubscribeOrUnsubscribe = (\n  topics: string | string[],\n  store: Store | null,\n  client: MqttClient | null,\n) => {\n  return (\n    hasAllValidTopics(topics) && hasStore(store) && isClientConnected(client)\n  );\n};\n","import { Store } from '@reduxjs/toolkit';\nimport { matches, exec } from 'mqtt-pattern';\nimport { MqttClient, IClientSubscribeOptions } from 'precompiled-mqtt';\nimport invariant from 'tiny-warning';\n\nimport { createWorkflowAction } from './ducks/utils';\nimport { addProcess, removeProcess } from './ducks/workflowManager.slice';\nimport { WorkflowManagerConfigProps } from './types';\nimport {\n  ERROR_MESSAGES,\n  isValidJSON,\n  shouldSubscribeOrUnsubscribe,\n  PROCESS_TOPIC_PATTERN,\n} from './utils';\n\nclass WorkflowManagerConfig implements WorkflowManagerConfigProps {\n  private static _client: MqttClient | null = null;\n  private static _store: Store | null = null;\n  private static _instance = new WorkflowManagerConfig();\n\n  constructor() {\n    this._setInstance(this);\n    this.subscribe = this.subscribe.bind(this);\n  }\n\n  private _setInstance(instance: WorkflowManagerConfig): void {\n    if (!WorkflowManagerConfig._instance) {\n      WorkflowManagerConfig._instance = instance;\n    }\n  }\n\n  private _onMessageArrived(subscribeTopic: string | string[]) {\n    return (topic: string, message: Buffer) => {\n      const payloadString = message.toString();\n\n      if (!isValidJSON(payloadString)) {\n        invariant(false, ERROR_MESSAGES.INVALID_JSON);\n        return;\n      }\n\n      const topics = [subscribeTopic].flat();\n      const isMatched = topics.some((subTopic) => matches(subTopic, topic));\n\n      if (isMatched) {\n        const store = WorkflowManagerConfig._store;\n        const dispatch = store?.dispatch as Store['dispatch'];\n        const payload = JSON.parse(message.toString());\n        const action = payload?.props?.action || '';\n        const result = payload?.props?.result || {};\n\n        dispatch(createWorkflowAction(action, result));\n      }\n    };\n  }\n\n  public static getInstance(): Readonly<WorkflowManagerConfig> {\n    return Object.freeze(WorkflowManagerConfig._instance);\n  }\n\n  public static setMqttClient(client: MqttClient): void {\n    this._client = client;\n  }\n\n  public static getStore(): Store | null {\n    return this._store;\n  }\n\n  /**\n   * @description Set the redux store. This is used to dispatch actions in the workflow manager.\n   * @param {Store} store\n   * @returns {void}\n   */\n  public setStore(store: Store): void {\n    WorkflowManagerConfig._store = store;\n  }\n\n  /**\n   * @description The MQTT Client instance is intended for external react component. Be sure to use this after de WorkflowManager component has been mounted.\n   * @returns {MqttClient | null}\n   */\n  public getMqttClient(): MqttClient | null {\n    return WorkflowManagerConfig._client;\n  }\n\n  /**\n   * @description Subscribe to a topic or topics.\n   * @param {(string | string[])} topic\n   * @param {IClientSubscribeOptions} options\n   */\n  public subscribe(\n    topic: string | string[],\n    options: IClientSubscribeOptions = {} as IClientSubscribeOptions,\n  ): void {\n    const client = this.getMqttClient();\n    const store = WorkflowManagerConfig._store;\n\n    const shouldSubscribe = shouldSubscribeOrUnsubscribe(topic, store, client);\n\n    if (!shouldSubscribe) return;\n\n    const dispatch = store?.dispatch as Store['dispatch'];\n\n    const topics = [topic].flat();\n\n    topics.forEach((subTopic) => {\n      const topicParams = exec(PROCESS_TOPIC_PATTERN, subTopic);\n      const processId = topicParams?.processId || '';\n\n      if (processId) dispatch(addProcess(processId));\n    });\n\n    client?.subscribe(topic, options);\n    client?.on('message', this._onMessageArrived(topic));\n  }\n\n  public unsubscribe(topic: string | string[]): void {\n    const client = this.getMqttClient();\n    const store = WorkflowManagerConfig._store;\n\n    const unsubscribe = shouldSubscribeOrUnsubscribe(topic, store, client);\n\n    if (!unsubscribe) return;\n\n    const dispatch = store?.dispatch as Store['dispatch'];\n    const topics = [topic].flat();\n\n    client?.unsubscribe(topic);\n    topics.forEach((subTopic) => {\n      dispatch(removeProcess(subTopic));\n    });\n  }\n}\n\nexport default WorkflowManagerConfig;\n","export const isValidJSON = (json: string): boolean => {\n  try {\n    JSON.parse(json);\n  } catch (e) {\n    return false;\n  }\n  return true;\n};\n","import { createAction } from '@reduxjs/toolkit';\n\nimport { prefix } from './workflowManager.slice';\n\nexport const createWorkflowAction = (\n  workflowAction: string,\n  payload: Record<string, unknown>,\n) => {\n  const actionName = `${prefix}/external/${workflowAction}`;\n\n  return createAction<typeof payload>(actionName)(payload);\n};\n","import { createContext } from 'react';\n\nimport { IMqttContext } from './types';\n\nexport const MqttContext = createContext<IMqttContext | undefined>(undefined);\n\nexport const MqttProvider = MqttContext.Provider;\n","import Config from './WorkflowManagerConfig';\n\nexport * from './WorkflowManager';\nexport * from './hooks';\nexport * from './types';\nexport * from './ducks';\n\nexport const WorkflowManagerConfig = Config.getInstance();\n","import React, { FC, useCallback, useEffect, useMemo, useState } from 'react';\n\nimport { connect, MqttClient } from 'precompiled-mqtt';\nimport invariant from 'tiny-warning';\n\nimport { MqttProvider, IMqttContext } from './contexts';\nimport { WorkflowManagerProps } from './types';\nimport { ERROR_MESSAGES } from './utils';\nimport WorkflowManagerConfig from './WorkflowManagerConfig';\n\nexport const WorkflowManager: FC<WorkflowManagerProps> = ({\n  brokerUrl = '',\n  options,\n  children,\n}) => {\n  const [client, setClient] = useState<MqttClient | null>(null);\n  const [status, setStatus] = useState<IMqttContext['status']>('offline');\n  const [error, setError] = useState<IMqttContext['error']>(null);\n\n  const init = useCallback(() => {\n    if (!client) {\n      try {\n        const mqttInstance = connect(brokerUrl, options);\n\n        mqttInstance.on('connect', () => {\n          setStatus('connected');\n        });\n\n        mqttInstance.on('end', () => {\n          setStatus('offline');\n        });\n\n        mqttInstance.on('offline', () => {\n          setStatus('offline');\n        });\n\n        mqttInstance.on('error', () => {\n          setStatus('error');\n          invariant(false, ERROR_MESSAGES.ERROR_OCURRED);\n        });\n\n        mqttInstance.on('reconnect', () => {\n          setStatus('reconnecting');\n        });\n\n        setClient(mqttInstance);\n        WorkflowManagerConfig.setMqttClient(mqttInstance);\n      } catch (error) {\n        setStatus('error');\n        setError(error as Error);\n        invariant(false, ERROR_MESSAGES.FAILED_TO_CONNECT);\n      }\n    }\n  }, [brokerUrl, options, client]);\n\n  useEffect(() => {\n    init();\n  }, [init]);\n\n  const providerValue = useMemo(() => {\n    return { client, status, error };\n  }, [client, status, error]);\n\n  return <MqttProvider value={providerValue}>{children}</MqttProvider>;\n};\n","import { useContext } from 'react';\n\nimport invariant from 'tiny-warning';\n\nimport { MqttContext, IMqttContext } from '../contexts';\nimport { ERROR_MESSAGES } from '../utils';\n\nexport const useMqtt = (): IMqttContext => {\n  const context = useContext(MqttContext);\n\n  invariant(context, ERROR_MESSAGES.NO_WRAPPER);\n\n  return context as IMqttContext;\n};\n","import { useMemo } from 'react';\n\nimport { WorkflowManagerConfig } from '..';\n\n/**\n * @description Subscribe to a topic or topics.\n */\nexport const useSubscribe = () => {\n  return useMemo(() => WorkflowManagerConfig.subscribe, []);\n};\n","import { useMemo } from 'react';\n\nimport { WorkflowManagerConfig } from '..';\n\n/**\n * @description Subscribe to a topic or topics.\n */\nexport const useUnsubscribe = () => {\n  return useMemo(() => WorkflowManagerConfig.unsubscribe, []);\n};\n"],"names":["workflowManagerSlice","createSlice","name","initialState","activeProcesses","reducers","_reducers","state","action","push","payload","filter","process","prefix","addProcess","actions","removeProcess","reducer","VALID_TOPIC_PATTERN","isValidTopic","topic","test","shouldSubscribeOrUnsubscribe","topics","store","client","isValid","Array","isArray","every","invariant","hasAllValidTopics","hasStore","connected","isClientConnected","WorkflowManagerConfig","this","_setInstance","subscribe","bind","_proto","prototype","instance","_instance","_onMessageArrived","subscribeTopic","message","json","JSON","parse","e","isValidJSON","toString","flat","some","subTopic","matches","_payload$props","_payload$props2","_store","dispatch","workflowAction","createAction","createWorkflowAction","props","result","getInstance","Object","freeze","setMqttClient","_client","getStore","setStore","getMqttClient","options","forEach","topicParams","exec","processId","on","unsubscribe","MqttContext","createContext","undefined","MqttProvider","Provider","Config","_ref","brokerUrl","_ref$brokerUrl","children","_useState","useState","setClient","_useState2","status","setStatus","_useState3","error","setError","init","useCallback","mqttInstance","connect","useEffect","providerValue","useMemo","React","value","context","useContext"],"mappings":"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"}